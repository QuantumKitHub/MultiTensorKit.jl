var documenterSearchIndex = {"docs":
[{"location":"references/#References-used-in-documentation","page":"References","title":"References used in documentation","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Etingof,Â P.; Gelaki,Â S.; Nikshych,Â D. and Ostrik,Â V. (2016). Tensor Categories. Mathematical Surveys and Monographs (American Mathematical Society).\n\n\n\nEtingof,Â P.; Nikshych,Â D.; Ostrik,Â V. and Meir (2009). Fusion categories and homotopy theory, arXiv:0909.3140 [math.QA].\n\n\n\nLootens,Â L.; Delcamp,Â C.; Ortiz,Â G. and Verstraete,Â F. (2023). Dualities in One-Dimensional Quantum Lattice Models: Symmetric Hamiltonians and Matrix Product Operator Intertwiners. PRXÂ Quantum 4.\n\n\n\nLootens,Â L.; Delcamp,Â C. and Verstraete,Â F. (2024). Entanglement and the density matrix renormalisation group in the generalised Landau paradigm, arXiv:2408.06334 [quant-ph].\n\n\n\n","category":"page"},{"location":"lib/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/library/#MultiTensorKit.BimoduleSector","page":"Library","title":"MultiTensorKit.BimoduleSector","text":"struct BimoduleSector{Name} <: Sector\nBimoduleSector{Name}(i::Int, j::Int, label::Int)\n\nRepresents objects in the component subcategory ð’žáµ¢â±¼ of the multifusion category ð’ž = áµ¢â±¼ ð’žáµ¢â±¼,  where ð’ž is identified as Name. \n\nFields\n\ni::Int: The row index of the object in the matrix representation of the multifusion category.\nj::Int: The column index of the object in the matrix representation of the multifusion category.\nlabel::Int: The label of the object within the component subcategory.\n\n\n\n\n\n","category":"type"},{"location":"man/multifusioncats/#Extending-to-multifusion-category-theory","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"","category":"section"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"This section will explain how to go from a fusion category to a multifusion category, as well as why one would want to consider the latter. Multifusion categories naturally embed the structure of bimodule categories. To explain this, we must start by explaining module categories over fusion categories, following this up with (invertible) bimodule categories, and finishing off with the multifusion structure.","category":"page"},{"location":"man/multifusioncats/#Module-categories","page":"Extending to multifusion category theory","title":"Module categories","text":"","category":"section"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"We will mostly use the notation in Lootens et al. for fusion categories and module categories over these. We start from a fusion category mathcalD defined by the triple (otimes_mathcalD mathbb1_mathcalD ^mathcalDF) with simple objects alpha beta  in mathcalI_mathcalD. We drop the mathcalD subscript when there is no ambiguity concerning the fusion category. We call its associator ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"^mathcalDF^alpha beta gamma alpha otimes (beta otimes gamma) rightarrow (alpha otimes beta) otimes gamma","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"the monoidal associator.  An F-move is now graphically portrayed as:","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"<img src=\"../img/Fmove_D.svg\" alt=\"\" width=\"100%\" class=\"color-invertible\"/>","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"We can consider the right module category mathcalM over mathcalD, which is a category (not necessarily fusion!) with (isomorphism classes of) simple objects mathcalI_mathcalM = AB, a right action ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"triangleleft mathcalM times mathcalD rightarrow mathcalM","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"and the right module associator ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"^triangleleftF^Aalphabeta A triangleleft (alpha otimes beta) rightarrow (A triangleleft alpha) triangleleft beta","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"An F-move with this module associator can be expressed as:","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"<img src=\"../img/Fmove_MD.svg\" alt=\"\" width=\"100%\" class=\"color-invertible\"/>","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"The module structure of mathcalM is now defined as the triple (mathcalM triangleleft ^triangleleftF). The right module associator now satisfies a mixed pentagon equation with ^mathcalDF. ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"Similarly, we can define a left module category (mathcalM triangleright ^trianglerightF) over a fusion category (otimes_mathcalC 1_mathcalC ^mathcalCF). The functor is now a left action of mathcalC on mathcalM ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"triangleright mathcalC times mathcalM rightarrow mathcalM","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"while the left module associator is a natural isomorphism that acts as","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"^trianglerightF^abA (a otimes b) triangleright A rightarrow a triangleright (b triangleright A)","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"for mathcalI_mathcalC = ab. The left module associator also fulfills a mixed pentagon equation with ^mathcalCF. An F-move with ^mathcalCF takes on the form:","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"<img src=\"../img/Fmove_CM.svg\" alt=\"\" width=\"100%\" class=\"color-invertible\"/>","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"We can combine the concepts of left and right module categories as follows. Say there are two fusion categories mathcalC and mathcalD. A (mathcalC mathcalD)-bimodule category is a module category, now defined through a sextuple (mathcalM triangleright triangleleft ^trianglerightF ^triangleleftF ^triangleright hspace-12mutriangleleftF) such that (mathcalM triangleright ^trianglerightF) is a left mathcalC-module category, and (mathcalM triangleleft ^triangleleftF) is a right mathcalD-module category, and with additional structure such that the bimodule associator acts as ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"^triangleright hspace-12mutriangleleftF^aAalpha (a triangleright A) triangleleft alpha rightarrow a triangleright (A triangleleft alpha)","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"for a in mathcalI_mathcalC alpha in mathcalI_mathcalD A in mathcalI_mathcalM. The bimodule associator fulfills a mixed pentagon equation with the module associators. An F-move with ^triangleright hspace-12mutriangleleftF is given by:","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"<img src=\"../img/Fmove_CMD.svg\" alt=\"\" width=\"100%\" class=\"color-invertible\"/>","category":"page"},{"location":"man/multifusioncats/#Opposite-module-categories","page":"Extending to multifusion category theory","title":"Opposite module categories","text":"","category":"section"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"Consider a fusion category mathcalD and a right module category mathcalM over mathcalD. We can define mathcalM^textop to be the opposite category of mathcalM (Etingof et al., 2009). Then mathcalM^textop is a left module category over mathcalD. A similar statement can be made starting from a left module category and getting an opposite right module category. In particular, given a (mathcalC mathcalD)-bimodule category mathcalM over the fusion categories mathcalC mathcalD, we see immediately that mathcalM^textop is a (mathcalD mathcalC)-bimodule category.","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"Interestingly, due to the opposite actions","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"triangleleft^textop mathcalD times mathcalM^textop rightarrow mathcalM^textop","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"and ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"triangleright^textop mathcalM^textop times mathcalC rightarrow mathcalM^textop","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"there is a valid notion of multiplying a module category with its opposite:","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"mathcalM times mathcalM^textop rightarrow mathcalC quad mathcalM^textop times mathcalM rightarrow mathcalD","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"something something morita equivalence and invertible bimodule, maybe drinfeld center, maybe anyons, maybe domain walls","category":"page"},{"location":"man/multifusioncats/#Multifusion-categories","page":"Extending to multifusion category theory","title":"Multifusion categories","text":"","category":"section"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"A fusion category has the important condition that mathsfEnd_mathcalC(1_mathcalC) cong mathbbC, i.e., the unit of the fusion category is simple. If we drop this condition, then we consider a multifusion category. We assume the multifusion category itself to be indecomposable, meaning it is not the direct sum of two non-trivial multifusion categories. Let us call this multifusion category mathcalC. It will be clear in a moment that this will not be ambiguous. Its unit can then be decomposed as","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"1_mathcalC = bigoplus_i=1^r 1_r","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"i.e., it is decomposed into simple unit objects of the subcategories mathcalC_ij coloneqq 1_i otimes mathcalC otimes 1_j. With this, we see that the multifusion category itself can be decomposed into its subcategories","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"mathcalC = bigoplus_ij=1^r mathcalC_ij","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"We call this an r times r multifusion category. Due to this structure, we represent a simple object in the multifusion category \"Name\" by","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"struct BimoduleSector{Name} <: Sector\n    i::Int\n    j::Int\n    label::Int\nend","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"i and j specify which subcategory mathcalC_ij we are considering, and label selects a particular simple object within that subcategory.","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"We want to consider multifusion categories because their structure encapsulates that of (bi-)module categories. Every diagonal category mathcalC_ii coloneqq mathcalC_i (also known as a component category) is a fusion category, and every off-diagonal category mathcalC_ij is an invertible (mathcalC_i mathcalC_j)-bimodule category. That way, as long as we know how the simple objects of the fusion and module categories fuse with one another, and we can determine all the monoidal and module associators, we can treat the multifusion category as one large fusion category with limited fusion rules. In particular, the tensor product ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"otimes_mathcalC mathcalC_ij times mathcalC_kl rightarrow delta_jkmathcalC_il","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"takes on the same structure as the product of two matrix units. This is not a coincidence; there is a deep relation between multifusion categories and matrix algebras (Etingof et al., 2016; Section 4.3). ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"Given a subcategory mathcalC_ij, we can define the left unit as the unit object of the fusion category mathcalC_i, while the right unit is the unit object of the fusion category mathcalC_j. In other words, the left unit of mathcalC_ij is the unique object of the multifusion category mathcalC for which","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"1_i otimes_mathcalC M_ij = M_ij quad forall M_ij in mathcalC_ij","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"and similarly for the right unit of mathcalC_ij,","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"M_ij otimes_mathcalC 1_j = M_ij quad forall M_ij in mathcalC_ij","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"We can also immediately see that for a (bi)module subcategory mathcalC_ij, the opposite (bi)module subcategory mathcalC_ij^textop equiv mathcalC_ji, and as expected,","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"mathcalC_ij times mathcalC_ji rightarrow mathcalC_i","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"just like what we concluded when considering opposite module categories outside of the multifusion structure.","category":"page"},{"location":"man/multifusioncats/#2-category-and-coloring","page":"Extending to multifusion category theory","title":"2-category and coloring","text":"","category":"section"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"Multifusion categories can also be interpreted as 2-categories. We still interpret the objects of this 2-category the same way. The 1-morphisms are the subcategories themselves, and the 2-morphisms the morphisms of the multifusion category. The graphical calculus of monoidal 1-categories can be extended to 2-categories by use of colorings. We have previously differed between module strands and fusion strands by the color of the strand itself. However, in 2-categories the strands (1-morphisms) separate regions which are colored based on the objects they are representing. Since we draw the strands vertically, a single strand results in a left and right region, and the colorings will determine the fusion category which fuses from the left or right with that single strand. In particular, fusion strands necessarily have the same coloring on the left and right, while module strands have a mismatching coloring. ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"The simplest non-trivial fusion diagram is a trivalent junction:","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"<img src=\"../img/Nsymbol_coloring.svg\" alt=\"\" width=\"100%\" class=\"color-invertible\"/>","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"The most general case is the top left figure, where all three regions have a different coloring. The top middle region having the same coloring from the top left and top right strands follow from the delta function in the tensor product definition. However, as will be explained more in detail later, this most general trivalent junction with three colorings will never be needed. In short, we will always be considering a single bimodule category mathcalC_ij at a time, and the only other non-diagonal subcategory which fuses with this is its opposite mathcalC_ji. This is displayed in the top middle and right. Similarly, two colorings are required when considering the fusion between a fusion and module strand, shown in the bottom left and middle figure. The simplest trivalent junctions boil down to fusions within fusion categories, which is obviously drawn with just one color. This is shown in the bottom right.","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"With this coloring system, we can specify which associator must be called to perform a particular F-move. Such an F-move would look like","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"<img src=\"../img/Fmove_coloring.svg\" alt=\"\" width=\"100%\" class=\"color-invertible\"/>","category":"page"},{"location":"man/multifusioncats/#Why-opposite-module-categories-end-up-being-necessary-in-MultiTensorKit","page":"Extending to multifusion category theory","title":"Why opposite module categories end up being necessary in MultiTensorKit","text":"","category":"section"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"One of the common manipulations which can act on a tensor map is the transposition of vector spaces. We will refer to this as the bending of legs. One of the elementary bends is the right bend, where one of the tensor legs is bent along the right from the codomain to the domain, or vice versa. At the level of the tensor, a covariant index becomes contravariant, or vice versa. Similarly, a left bend can also be performed, bending the leg along the left. This guarantees that legs will not cross, preventing braidings which require extra data known as R-symbols. ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"Linear algebra tells us that given a (finite-dimensional) vector space V with a basis denoted e_irangle, one can consider the dual vector space V^*, whose dual basis langle e_i^* satisfies the property langle e_j^*  e_i rangle = delta_ij. In the diagrammatic calculus, specifying whether a tensor map leg represents a vector space or its dual is done with an arrow. Following the TensorKit convention, legs with arrows pointing downwards are vector spaces, and arrows pointing upwards state that we are considering its dual. In particular, at the level of fusion trees we can also draw arrows on the strands to denote whether we are considering morphisms between objects or dual objects. ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"In principle, choosing to bend e.g. codomain legs to the right and domain legs to left is an arbitrary choice, but would require to distinguish between left and right transposes. However, TensorKit.jl is implemented in a way that does not differentiate the two. In particular, we do not have to worry about this when considering categorical symmetries where, in principle, the left and right dual of an object are not equivalent. This is because this left-right symmetry is guaranteed when considering unitary fusion categories, which is what is done in TensorKit and necessarily in MultiTensorKit. ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"For this reason, at the level of the fusion trees the topological move that is performed to bend the legs along the right is called a B-move. Graphically, one can show that this bend boils down to a particular F-move. The typical equation found in the literature is the following:","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"<img src=\"../img/Bmove_lit.svg\" alt=\"\" width=\"100%\" class=\"color-invertible\"/>","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"... The reason to only consider B-moves is rooted in the choice of canonical form of fusion trees within TensorKit, where fusions are iterated over from left to right and splittings from right to left. ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"Importantly, we identify the dual vector space labeled by a module category with a vector space labeled by the opposite module category. Consequently,","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"mathcalM^* simeq mathcalM^textop","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"In the multifusion setting, this can also be seen graphically. By keeping track of the colorings and the directions of the arrows of the legs, one can see that we need to slightly modify the expression for the B-move to the following:","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"<img src=\"../img/Bmove_MF.svg\" alt=\"\" width=\"100%\" class=\"color-invertible\"/>","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"where by mathbb1_j we mean the unit of mathcalC_j. ","category":"page"},{"location":"man/multifusioncats/#More-on-the-topological-data:-gauge-choices-and-distilling-properties-of-the-subcategories","page":"Extending to multifusion category theory","title":"More on the topological data: gauge choices and distilling properties of the subcategories","text":"","category":"section"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"The most generic F-move contains 4 colors. For that reason, MultiTensorKit will require the F-symbol data to provided as some data file (currently .txt) with 4 + 6 + 4 + 2 = 16 columns. The first 4 refer to the colors, the following 6 label the simple objects of the corresponding subcategories, the next 4 label multiplicities, and the final 2 provide the real and imaginary value of the F-symbol itself.","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"In a similar manner, the N-symbols contain maximally three colors, so these data must provide 3 columns labeling the colors, 3 columns labeling the simple objects and a final column with the dimension of the corresponding vector space.","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"Besides the B-move (and closely related A-move, which we do not illustrate), we can also see how the quantum dimension and Frobenius-Schur indicator expressions get modified. We already know that an F-move of the form F^c barc c_c needs to be evaluated for these topological data. Graphically, we find that","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"<img src=\"../img/qdim_fs_MF.svg\" alt=\"\" width=\"50%\" class=\"center color-invertible\"/>","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"An important property of the F-symbols is that they must satisfy the triangle identities. In fusion category theory, this states that isomorphisms between (simple) objects a and the tensor product between a and the unit mathbb1 exists, and that ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"(a otimes mathbb1) otimes b cong a otimes (mathbb1 otimes b)","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"for b in the same fusion category. This can be straightforwardly generalised to multifusion categories. This requires a particular gauging of these trivalent vertices.","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"Besides the triangle identities, the (multi)fusion category must also fulfill the pentagon equations. These encapsulate the two identical manners to evaluating the fusion of four objects in the (multi)fusion category. Every fusion category's F-symbols must satisfy these individually, but also the (bi)module associators between bimodule and fusion categories. One can check that, for every pair of fusion categories, their bimodule category and opposite bimodule category, there are 32 pentagon equations to be satisfied. In the multifusion notation, they can be represented by","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"<img src=\"../img/pentagon_colored.svg\" alt=\"\" width=\"100%\" class=\"color-invertible\"/>","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"We briefly mentioned earlier how unitary F-symbols are required within TensorKit, and thus necessarily MultiTensorKit. ","category":"page"},{"location":"man/multifusioncats/#Braiding","page":"Extending to multifusion category theory","title":"Braiding","text":"","category":"section"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"A very important aspect of MultiTensorKit is that all BimoduleSectors are defined to not support braiding: TensorKitSectors.BraidingStyle(::Type{<:BimoduleSector}) = NoBraiding(). We do this for two reasons. On the one hand, there is no natural 1-categorical way of defining braidings between the components of the multifusion category. It is possible that the diagonal fusion categories themselves are braided, but a \"componentwise\" braiding is unwise to support. On the other hand, it is entirely possible to write matrix product state manipulations in a planar manner (which has been done in MPSKit), thus avoiding the need of a braiding tensor. ","category":"page"},{"location":"man/multifusioncats/#Examples-of-multifusion-categories","page":"Extending to multifusion category theory","title":"Examples of multifusion categories","text":"","category":"section"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"Without specifying any of the categories, the simplest non-trivial multifusion category is a 2times 2 one, and the categories can be organised in a matrix as","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"mathcalC = beginpmatrix mathcalC_1  mathcalM  mathcalM^textop  mathcalC_2endpmatrix","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"We already identified the off-diagonal elements with module categories over the fusion categories on the diagonal. Accordingly, mathcalM is a (mathcalC_1 mathcalC_2)-bimodule category, and mathcalM^textop is the opposite module category and a (mathcalC_2 mathcalC_1)-bimodule category. ","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"If we take mathcalC_1 = mathcalC_2 = mathsfRep(mathbbZ_2) and mathcalM = mathsfVec, then the entire multifusion category is isomorphic to the mathsfIsing category (Etingof et al., 2016; Example 4.10.5). We identify the trivial representation of mathsfRep(mathbbZ_2) with the unit of mathsfIsing, the sign representation with psi and the unique object of mathsfVec with the duality object sigma. One can easily check that the fusion rules of mathsfIsing match with those we expect within mathsfRep(mathbbZ_2) and with its module category mathsfVec. Additionally, the fusion between mathsfVec and mathsfVec^textop (and vice-versa) giving every object in mathcalC_1 (mathcalC_2) is consistent with sigma times sigma^* = 1 + psi. This particular example can be found in TensorKitSectors.","category":"page"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"This construction can be generalised to mathcalC_1 = mathcalC_2 = mathsfRep(G) with mathsfG a finite abelian group, such that the entire multifusion category is isomorphic to the Tambara-Yamagami category mathsfTY(mathsfG) (with positive Frobenius-Schur indicator for our purposes), and mathsfVec will represent the duality object which squares to all invertible objects of the original group. To be exact, one of the diagonal fusion categories should be mathsfVec_G for the correct Morita dual relation, but it is known for abelian groups that this is isomorphic to mathsfRep(G).","category":"page"},{"location":"man/multifusioncats/#Module-and-multifusion-categories-in-condensed-matter-physics","page":"Extending to multifusion category theory","title":"Module and multifusion categories in condensed matter physics","text":"","category":"section"},{"location":"man/multifusioncats/","page":"Extending to multifusion category theory","title":"Extending to multifusion category theory","text":"boundaries of string-net models\ngeneralised anyonic spin chain\nmoore-seiberg data -> modular invariant\nmodules as (conformal) boundary conditions","category":"page"},{"location":"man/fusioncats/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"The manual has been divided into different sections in an attempt to break down the information the user requires to use MultiTensorKit.jl. We start off with a short summary of fusion category theory. Users familiar with TensorKit.jl may have read the Optional introduction to category theory in the documentation of TensorKit; this section can then largely be skipped. Be aware that notation may differ from the literature.","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"Afterwards, the extension to multifusion categories is explained, and its relation to (bi)module categories over fusion categories is shown. ","category":"page"},{"location":"man/fusioncats/#Fusion-category-theory","page":"Introduction","title":"Fusion category theory","text":"","category":"section"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"The aim of this section is to explain the bare minimum required to proceed to the next section on multifusion category theory and bimodule categories. More details can be found in the TensorKit documentation or the book Tensor Categories (Etingof et al., 2016).","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"Let us start simple and introduce the fusion ring mathcalC in a black-box manner. This ring ","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"consists of finitely many simple objects  X_1 X_2  X_R , with R the rank of the fusion ring,\nwhich can be fused with one another: X_i otimes X_j cong sum_k N_ij^k X_k introducing the N-symbol N_ij^k in mathbbN in the fusion rules,\ncontains a unique unit object 1_mathcalC which satisfies 1_mathcalC otimes X_i cong X_i otimes 1_mathcalC cong X_i for all objects X_i in mathcalC,\nhas a dual object overlineX for every object X such that X otimes overlineX cong overlineX otimes X cong 1_mathcalC oplus , generalising the notion of the inverse element.","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"To extend the fusion ring to the fusion category, we need to add the following structure:","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"Consider only the representatives of isomorphism classes of simple objects mathcalI_mathcalC,\nThe associator F^X_iX_jX_k (X_i otimes X_j) otimes X_k xrightarrowsim X_i otimes (X_j otimes X_k)  which fulfills the famous pentagon equation,\nMorphisms between (simple) objects textHom_mathcalC(X_i X_j), which are empty vector spaces unless the objects are isomorphic, the latter then giving mathbbC,\nMore general morphisms textHom_mathcalC(X_i otimes X_j X_k) cong mathbbC^N_ij^k.","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"This way, we can describe fusion categories by a triple (otimes 1_mathcalC F) of mathcalC defining its monoidal product, unit object and monoidal associator, the latter also commonly called the F-symbol. In particular, the simple objects have their respective quantum dimensions d_i = dim(X_i) which form their own one-dimensional representation of the fusion algebra: d_i d_j = sum_k N_ij^k d_k. In particular, the unit object always has quantum dimension 1, and all other quantum dimensions are larger or equal to one. These quantum dimensions are encoded in the F-symbol. The isomorphisms instead of the equalities are a technical detail, so we drop that notation. ","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"Vectors in these hom-spaces are graphically denoted as living in the trivalent junction","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"<img src=\"../img/homvector.svg\" alt=\"\" width=\"50%\" class=\"center color-invertible\"/>","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"With the F-symbol, we can perform F-moves:","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"<img src=\"../img/Fmove.svg\" alt=\"\" width=\"100%\" class=\"color-invertible\"/>","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"TensorKit requires the F-symbols to be unitary. This way, we can interpret the F-symbol F^ijk_l as a unitary matrix, and the F-move as a unitary basis transformation. Unitarity is also useful from a diagrammatic point of view because the category is then equipped with a pivotal and spherical structure. This essentially means that morphisms can be drawn and moved around freely on a 2-sphere, such that vector spaces can be moved freely from domain (codomain) to codomain (domain). ","category":"page"},{"location":"man/fusioncats/#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"man/fusioncats/#\\mathsf{VecG}-and-\\mathsf{RepG}","page":"Introduction","title":"mathsfVecG and mathsfRepG","text":"","category":"section"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"Colloquially speaking, category theory attempts to generalise mathematical structures and their relations in a way that different structures can be treated in an equal manner. This is noted in particular as fusion category theory encompasses not only finite and compact groups, but also their representations. We show a table sketching how these are put on equal footing categorically.","category":"page"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"mathsfVecG mathsfRepG Categorical generalisation\nG-graded vector spaces V_1 V_2  Representations of G (V_1 pi_1) (V_2 pi_2)  Objects\nG-graded preserving linear maps phi V rightarrow W Intertwiners f V_1 rightarrow V_2, f circ pi_1 = pi_2 circ f Morphisms textHom_mathcalC\n1d subspaces mathbbC_g_1 mathbbC_g_2:  textHom_mathsfVecG(mathbbC_g_1mathbbC_g_2) = delta_g_1g_2 Irreps: textHom_mathsfRepG(rho_irho_j) = delta_ij mathbbC (Schur) Simple objects: textHom_mathcalC(ab) = delta_abmathbbC\nG-graded tensor product (V otimes W)_g = oplus_hk=g V_h otimes W_k pi_i otimes pi_j simeq oplus_i N_ij^krho_k Direct sum, monoidal product, fusion rules, multiplicity\nmathbbC_1 otimes W simeq W simeq W otimes mathbbC_1 Trivial rep 1: 1 otimes rho = rho = rho otimes 1 Monoidal unit 1_mathcalC\nmathbbC_g otimes mathbbC_g^-1 = mathbbC_1 = mathbbC_g^-1 otimes mathbbC_g pi otimes overlinepi = 1 oplus  Dual object\nF(V otimes W) otimes U xrightarrowsimV otimes (W otimes U) F (pi_1 otimes pi_2) otimes pi_3 xrightarrowsim pi_1 otimes (pi_2 otimes pi_3) F-symbol","category":"page"},{"location":"man/fusioncats/#Fusion-categories-in-condensed-matter-physics","page":"Introduction","title":"Fusion categories in condensed matter physics","text":"","category":"section"},{"location":"man/fusioncats/","page":"Introduction","title":"Introduction","text":"String-net models -> non-chiral topological order classification\nKitaev's appendix E -> anyonic excitations\nGolden chain, anyonic spin chains\n","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"explain the f-symbol and n-symbol storage system","category":"page"},{"location":"man/implementation/#MultiTensorKit-implementation:-\\mathsf{Rep(A_4)}-as-an-example","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"","category":"section"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"This tutorial is dedicated to explaining how MultiTensorKit was implemented to be compatible with with TensorKit and MPSKit for matrix product state simulations. In particular, we will be making a generalised anyonic spin chain. We will demonstrate how to reproduce the entanglement spectra found in (Lootens et al., 2024). The model considered there is a spin-1 Heisenberg model with additional terms to break the usual mathsfU_1 symmetry to mathsfRep(A_4), while having a non-trivial phase diagram and relatively easy Hamiltonian to write down.","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"This will be done with the A4Object = BimoduleSector{A4} Sector, which is the multifusion category which contains the structure of the module categories over mathsfRep(A_4). Since there are 7 module categories, A4Object is a r=7 multifusion category. There are 3 fusion categories up to equivalence:","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"mathsfVec_A_4: the category of mathsfA_4-graded vector spaces. The group mathsfA_4 is order 42 = 12. It has thus 12 objects.\nmathsfRep(A_4): the irreducible representations of the group mathsfA_4, of which there are 4. One is the trivial representation, two are one-dimensional non-trivial and the last is three-dimensional.\nmathsfRep(H): the representation category of some Hopf algebra which does not have a name. It has 6 simple objects.","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"For this example, we will require the following packages:","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"using TensorKit, MultiTensorKit, MPSKit, MPSKitModels","category":"page"},{"location":"man/implementation/#Identifying-the-simple-objects","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"Identifying the simple objects","text":"","category":"section"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"We first need to select which fusion category we wish to use to grade the physical Hilbert space, and which fusion category to represent e.g. the symmetry category. In our case, we are interested in selecting mathcalD = mathsfRep(A_4) for the physical Hilbert space. We know the module categories over mathsfRep(G) to be mathsfRep^psi(H) for a subgroup mathsfH and 2-cocycle psi. Thus, the 7 module categories mathcalM one can choose over mathsfRep(A_4) are","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"mathsfRep(A_4) itself as the regular module category,\nmathsfVec: the category of vector spaces,\nmathsfRep(mathbbZ_2),\nmathsfRep(mathbbZ_3),\nmathsfRep(mathbbZ_2 times mathbbZ_2),\nmathsfRep^psi(mathbbZ_2 times mathbbZ_2),\nmathsfRep^psi(A_4).","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"When referring to specific fusion and module categories, we will use this non-multifusion notation.","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"The easiest way to identify which elements of the multifusion category correspond to the subcategories we wish to use is ... (not sure yet how to do this yet)","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"Now that we have identified the fusion and module categories, we want to select the relevant objects we wish to place in our graded spaces. Unfortunately, due to the nature of how the N-symbol and F-symbol data are generated, the objects of the fusion subcategories are not ordered such that label=1 corresponds to the unit object. Hence, the simplest way to find the unit object of a fusion subcategory is","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"one(A4Object(i,i,1))","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"Left and right units of subcategories are uniquely specified by their fusion rules. For example, the left unit of a subcategory mathcalC_ij is the simple object in mathcalC_i for which","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"^_a mathbb1 times a = a quad forall a in mathcalC_i","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"A similar condition uniquely defines the right unit of a subcategory. For fusion subcategories, a necessary condition is that the left and right units coincide.","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"Identifying the other simple objects of a (not necessarily fusion) category requires more work. We recommend a combination of the following to uniquely determine any simple object a:","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"Check the dimension of the simple object: dim(a)\nCheck the dual of the simple object: dual(a)\nCheck how this simple object fuses with other (simple) objects: Nsymbol(a,b,c)","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"The dual object of some simple object a of an arbitrary subcategory mathcalC_ij is defined as the unique object a^* in mathcalC_ji satisfying","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"^_a mathbb1 in a times a^* quad textand quad mathbb1_a in a^* times a","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"with multiplicity 1.","category":"page"},{"location":"man/implementation/#Constructing-the-Hamiltonian-and-matrix-product-state","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"Constructing the Hamiltonian and matrix product state","text":"","category":"section"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"TensorKit has been made compatible with the multifusion structure by keeping track of the relevant units in the fusion tree manipulations. With this, we can make GradedSpaces whose objects are in A4Object: ","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"D1 = A4Object(6, 6, 1) # unit in this case\nD2 = A4Object(6, 6, 2) # non-trivial 1d irrep\nD3 = A4Object(6, 6, 3) # non-trivial 1d irrep\nD4 = A4Object(6, 6, 4) # 3d irrep","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"Since we want to replicate a spin-1 Heisenberg model, it makes sense to use the 3-dimensional irrep to grade the physical space, and thus construct our Hamiltonian. We don't illustrate here how to derive the considered Hamiltonian in a mathsfRep(A_4) basis, but simply give it. For now, we construct a finite-size spin chain; below we will repeat the calculation for an infinite system.","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"P = Vect[A4Object](D4 => 1) # physical space\nT = ComplexF64\n# usual Heisenberg part\nh1_L = TensorMap(zeros, T, P âŠ— P â† P)\nh1_R = TensorMap(zeros, T, P â† P âŠ— P)\nblock(h1_L, D4) .= [0; 1]\nblock(h1_R, D4) .= [0 1;]\n@plansor h1[-1 -2; -3 -4] := h1_L[-1 1; -3] * h1_R[-2; 1 -4]\n\n# biquadratic term\nh2_L = TensorMap(zeros, T, P âŠ— Vect[A4Object](D1 => 1, D2 => 1, D3 => 1) â† P)\nh2_R = TensorMap(ones, T, P â† Vect[A4Object](D1 => 1, D2 => 1, D3 => 1) âŠ— P)\nblock(h2_L, D4) .= [4 / 3; 1 / 3; 1 / 3]\n@plansor h2[-1 -2; -3 -4] := h2_L[-1 1; -3] * h2_R[-2; 1 -4]\n\n# anti-commutation term\nh3_L = TensorMap(zeros, T, P âŠ— P â† P)\nh3_R = TensorMap(zeros, T, P â† P âŠ— P)\nblock(h3_L, D4) .= [1; 0]\nblock(h3_R, D4) .= [0 1;]\n@plansor h3[-1 -2; -3 -4] := h3_L[-1 1; -3] * h3_R[-2; 1 -4]\n\nL = 60\nJ1 = -2.0 # probing the A4 SSB phase first\nJ2 = -5.0\nlattice = FiniteChain(L)\nH1 = @mpoham sum(-2 * h1{i,j} for (i, j) in nearest_neighbours(lattice))\nH2 = @mpoham sum(h2{i,j} for (i, j) in nearest_neighbours(lattice))\nH3 = @mpoham sum(2im * h3{i,j} for (i, j) in nearest_neighbours(lattice))\n\nH = H1 + J1 * H2 + J3 * H3","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"For the matrix product state, we will select mathsfVec as the module category for now:","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"M = A4Object(1, 6, 1) # Vec","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"and construct the finite MPS:","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"D = 40 # bond dimension\nV = Vect[A4Object](M => D)\nVb = Vect[A4Object](M => 1) # non-degenerate boundary virtual space\ninit_mps = FiniteMPS(L, P, V; left=Vb, right=Vb)","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"warning: Important\nWe must pass on a left and right virtual space to the keyword arguments left and right of the FiniteMPS constructor, since these would by default try to place a trivial space of the Sector, which does not exist for any BimoduleSector due to the semisimple unit. ","category":"page"},{"location":"man/implementation/#DMRG2-and-the-entanglement-spectrum","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"DMRG2 and the entanglement spectrum","text":"","category":"section"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"We can now look to find the ground state of the Hamiltonian with two-site DMRG. We use this instead of the \"usual\" one-site DMRG because the two-site one will smartly fill up the blocks of the local tensor during the sweep, allowing one to initialise as a product state in one block and more likely avoid local minima, a common occurence in symmetric tensor network simulations. ","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"dmrg2alg = DMRG2(;verbosity=2, tol=1e-8, trscheme=truncbelow(1e-4))\nÏˆ, _ = find_groundstate(init_mps, H, dmrg2alg)","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"The truncation scheme keyword argument is mandatory when calling DMRG2 in MPSKit. Here, we choose to truncate such that all singular values are larger than 10^-4, while setting the default tolerance for convergence to 10^-8. More information on this can be found in the MPSKit documentation.","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"Now that we've found the ground state, we can compute the entanglement spectrum in the middle of the chain.","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"spec = entanglement_spectrum(Ïˆ, round(Int, L/2))","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"This returns a dictionary which maps the objects grading the virtual space to the singular values. In this case, there is one key corresponding to mathsfVec. We can also immediately return a plot of this data by the following:","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"using Plots # !\nentanglementplot(Ïˆ;site=round(Int, L/2))","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"This plot will show the singular values per object, as well as include the \"effective\" bond dimension, which is simply the dimension of the virtual space where we cut the system. #TODO: actually include the plot (or run everything as ipynb)","category":"page"},{"location":"man/implementation/#Search-for-the-correct-dual-model","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"Search for the correct dual model","text":"","category":"section"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"Consider a quantum lattice model with its symmetries determing the phase diagram. For every phase in the phase diagram, the dual model for which the ground state maximally breaks all symmetries spontaneously is the one where the entanglement is minimised and the tensor network is represented most efficiently (Lootens et al., 2024). Let us confirm this result, starting with the mathsfRep(A_4) spontaneous symmetry breaking phase. The code will look exactly the same as above, except the virtual space of the MPS will change to be graded by the other module categories:","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"module_numlabels(i) = MultiTensorKit._numlabels(A4Object, i, 6) \nV = Vect[A4Object](A4Object(i, 6, label) => D for label in 1:module_numlabels(i))\nVb = Vect[A4Object](c => 1 for c in first(sectors(V))) # not all charges on boundary, play around with what is there","category":"page"},{"location":"man/implementation/#Infinite-case","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"Infinite case","text":"","category":"section"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"Now, using MPKSit, we can perform matrix product state calculations. We construct some nearest-neighbour Hamiltonian and find the MPS representation of the ground state.","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"h = ones(ComplexF64, P âŠ— P â† P âŠ— P)\nH = @mpoham -sum(h{i,j} for (i,j) in nearest_neighbours(InfiniteChain(1)))\ninit = InfiniteMPS([P], [V])\n\ngs, envs = find_groundstate(init, H, VUMPS())","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"Besides VUMPS, IDMRG and IDMRG2 are as easy to run with the A4Object Sector.","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"A couple of MPSKit functions require an additional keyword argument sector (note the lowercase \"s\") specifying which sector to target within the function. These are:","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"transfer_spectrum: the sector is selected by adding an auxiliary space to the domain of each eigenvector of the transfer matrix. Since in a full contraction the domain of the eigenvector lies in the opposite side of the physical space (labeled by objects in mathcalD), the sectors lie in the symmetry category mathcalC.\ncorrelation_length: since this function calls transfer_spectrum, the same logic applies.\nexcitations with QuasiparticleAnsatz: similar to the previous functions, charged excitations are selected by adding a charged auxiliary space to the eigenvectors representing the quasiparticle states. ","category":"page"},{"location":"man/implementation/#Finite-case","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"Finite case","text":"","category":"section"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"There are minor differences to pay attention to when simulating matrix product states with a finite length. The first noticeable difference is in the FiniteMPS constructor itself to build an initial state. We must pass on a left and right virtual space to the keyword arguments left and right, since these would by default try to place a trivial space of the Sector, which does not exist for BimoduleSector due to the semisimple unit. Performing parallel calculations to the previous section now looks like","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"L = 10 # length of the MPS\ninit = FiniteMPS(L, P, V; left=V, right=V) # put Vec on the boundaries as well\nH = @mpoham sum(h{i,j} for (i,j) in nearest_neighbours(FiniteChain(L)))\n\ngs, envs = find_groundstate(init, H, DMRG())","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"DMRG2 will run in a similar manner. Additional sector keywords are present for the following:","category":"page"},{"location":"man/implementation/","page":"MultiTensorKit implementation: mathsfRep(A_4) as an example","title":"MultiTensorKit implementation: mathsfRep(A_4) as an example","text":"exact_diagonalization: the sector keyword argument now requires an object in mathcalD, since this is the fusion category which specifies the bond algebra from which the Hamiltonian is constructed. This is equivalent to adding a charged leg on the leftmost (or rightmost) virtual space of the MPS in conventional MPS cases.\nexcitations with QuasiparticleAnsatz: see infinite case.","category":"page"},{"location":"#MultiTensorKit","page":"Home","title":"MultiTensorKit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TensorKit extension to multifusion categories","category":"page"},{"location":"#Package-summary","page":"Home","title":"Package summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiTensorKit.jl provides the user a package to work with multifusion categories, the extension of regular fusion categories where the unit is no longer simple and unique. Multifusion categories naturally embed the structure of module categories over fusion categories. Hence, MultiTensorKit.jl allows not only the fusion of objects within the same fusion category (as TensorKit.jl), but also the fusion with and between module categories over these fusion categories. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultiTensorKit.jl is built to be compatible with TensorKit, thus allowing the construction of symmetric tensors with new symmetries due to the module structure. Through this, tensor network simulations of quantum many-body systems with aid of MPSKit.jl can be performed.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/fusioncats.md\", \"man/multifusioncats.md\",\"lib/library.md\", \"references.md\"]\nDepth = 2","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiTensorKit.jl is currently not registered to the Julia General Registry. You can install the package as","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/QuantumKitHub/MultiTensorKit.jl.git","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As the name suggests, MultiTensorKit is an extension of TensorKit.jl and TensorKitSectors.jl. Therefore, we recommend including TensorKit  to your project. Additionally, MultiTensorKit was made to be functional with MPSKit.jl and MPSKitModels.jl for Matrix Product State (MPS) calculations, supporting symmetries which go beyond TensorKit.","category":"page"}]
}
