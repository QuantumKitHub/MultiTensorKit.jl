<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MultiTensorKit implementation: mathsfRep(A_4) as a guiding example · MultiTensorKit.jl</title><meta name="title" content="MultiTensorKit implementation: mathsfRep(A_4) as a guiding example · MultiTensorKit.jl"/><meta property="og:title" content="MultiTensorKit implementation: mathsfRep(A_4) as a guiding example · MultiTensorKit.jl"/><meta property="twitter:title" content="MultiTensorKit implementation: mathsfRep(A_4) as a guiding example · MultiTensorKit.jl"/><meta name="description" content="Documentation for MultiTensorKit.jl."/><meta property="og:description" content="Documentation for MultiTensorKit.jl."/><meta property="twitter:description" content="Documentation for MultiTensorKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MultiTensorKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../fusioncats/">Introduction</a></li><li><a class="tocitem" href="../multifusioncats/">Extending to multifusion category theory</a></li><li class="is-active"><a class="tocitem" href>MultiTensorKit implementation: <span>$\mathsf{Rep(A_4)}$</span> as a guiding example</a><ul class="internal"><li><a class="tocitem" href="#Identifying-the-simple-objects"><span>Identifying the simple objects</span></a></li><li><a class="tocitem" href="#Constructing-the-Hamiltonian-and-matrix-product-state"><span>Constructing the Hamiltonian and matrix product state</span></a></li><li><a class="tocitem" href="#DMRG2-and-the-entanglement-spectrum"><span>DMRG2 and the entanglement spectrum</span></a></li><li><a class="tocitem" href="#Search-for-the-correct-dual-model"><span>Search for the correct dual model</span></a></li><li><a class="tocitem" href="#Differences-with-the-infinite-case"><span>Differences with the infinite case</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../lib/library/">Library</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>MultiTensorKit implementation: <span>$\mathsf{Rep(A_4)}$</span> as a guiding example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MultiTensorKit implementation: <span>$\mathsf{Rep(A_4)}$</span> as a guiding example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MultiTensorKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MultiTensorKit.jl/blob/main/docs/src/man/implementation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MultiTensorKit-implementation:-\\mathsf{Rep(A_4)}-as-a-guiding-example"><a class="docs-heading-anchor" href="#MultiTensorKit-implementation:-\\mathsf{Rep(A_4)}-as-a-guiding-example">MultiTensorKit implementation: <span>$\mathsf{Rep(A_4)}$</span> as a guiding example</a><a id="MultiTensorKit-implementation:-\\mathsf{Rep(A_4)}-as-a-guiding-example-1"></a><a class="docs-heading-anchor-permalink" href="#MultiTensorKit-implementation:-\\mathsf{Rep(A_4)}-as-a-guiding-example" title="Permalink"></a></h1><p>This tutorial is dedicated to explaining how MultiTensorKit was implemented to be compatible with with TensorKit and MPSKit for matrix product state simulations. In particular, we will be making a generalised anyonic spin chain. We will demonstrate how to reproduce the entanglement spectra found in (<a href="../../references/#Lootens_2024">Lootens <em>et al.</em>, 2024</a>). The model considered there is a spin-1 Heisenberg model with additional terms to break the usual <span>$\mathsf{U_1}$</span> symmetry to <span>$\mathsf{Rep(A_4)}$</span>, while having a non-trivial phase diagram and relatively easy Hamiltonian to write down.</p><p>This will be done with the <code>A4Object = BimoduleSector{A4}</code> <code>Sector</code>, which is the multifusion category which contains the structure of the module categories over <span>$\mathsf{Rep(A_4)}$</span>. Since there are 7 module categories, <code>A4Object</code> is a <span>$r=7$</span> multifusion category. There are 3 fusion categories up to equivalence:</p><ul><li><span>$\mathsf{Vec_{A_4}}$</span>: the category of <span>$\mathsf{A_4}$</span>-graded vector spaces. The group <span>$\mathsf{A}_4$</span> is order <span>$4!/2 = 12$</span>. It has thus 12 objects.</li><li><span>$\mathsf{Rep(A_4)}$</span>: the irreducible representations of the group <span>$\mathsf{A}_4$</span>, of which there are 4. One is the trivial representation, two are one-dimensional non-trivial and the last is three-dimensional.</li><li><span>$\mathsf{Rep(H)}$</span>: the representation category of some Hopf algebra which does not have a name. It has 6 simple objects.</li></ul><p>For this example, we will require the following packages:</p><pre><code class="language-julia hljs">using TensorKit, MultiTensorKit, MPSKit, MPSKitModels, Plots</code></pre><h2 id="Identifying-the-simple-objects"><a class="docs-heading-anchor" href="#Identifying-the-simple-objects">Identifying the simple objects</a><a id="Identifying-the-simple-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Identifying-the-simple-objects" title="Permalink"></a></h2><p>We first need to select which fusion category we wish to use to grade the physical Hilbert space, and which fusion category to represent e.g. the symmetry category. In our case, we are interested in selecting <span>$\mathcal{D} = \mathsf{Rep(A_4)}$</span> for the physical Hilbert space. We know the module categories over <span>$\mathsf{Rep(G)}$</span> to be <span>$\mathsf{Rep^\psi(H)}$</span> for a subgroup <span>$\mathsf{H}$</span> and 2-cocycle <span>$\psi$</span>. Thus, the 7 module categories <span>$\mathcal{M}$</span> one can choose over <span>$\mathsf{Rep(A_4)}$</span> are</p><ul><li><span>$\mathsf{Rep(A_4)}$</span> itself as the regular module category,</li><li><span>$\mathsf{Vec}$</span>: the category of vector spaces,</li><li><span>$\mathsf{Rep(\mathbb{Z}_2)}$</span>,</li><li><span>$\mathsf{Rep(\mathbb{Z}_3)}$</span>,</li><li><span>$\mathsf{Rep(\mathbb{Z}_2 \times \mathbb{Z}_2)}$</span>,</li><li><span>$\mathsf{Rep^\psi(\mathbb{Z}_2 \times \mathbb{Z}_2)}$</span>,</li><li><span>$\mathsf{Rep^\psi(A_4)}$</span>.</li></ul><p>When referring to specific fusion and module categories, we will use this non-multifusion notation.</p><p>The easiest way to identify which elements of the multifusion category correspond to the subcategories we wish to use is ... (not sure yet how to do this yet)</p><p>Now that we have identified the fusion and module categories, we want to select the relevant objects we wish to place in our graded spaces. Unfortunately, due to the nature of how the N-symbol and F-symbol data are generated, the objects of the fusion subcategories are not ordered such that <code>label=1</code> corresponds to the unit object. Hence, the simplest way to find the unit object of a fusion subcategory is</p><pre><code class="language-julia hljs">one(A4Object(i,i,1))</code></pre><p>Left and right units of subcategories are uniquely specified by their fusion rules. For example, the left unit of a subcategory <span>$\mathcal{C}_{ij}$</span> is the simple object in <span>$\mathcal{C}_i$</span> for which</p><p class="math-container">\[^{}_a \mathbb{1} \times a = a \quad \forall a \in \mathcal{C}_i.\]</p><p>A similar condition uniquely defines the right unit of a subcategory. For fusion subcategories, a necessary condition is that the left and right units coincide.</p><p>Identifying the other simple objects of a (not necessarily fusion) category requires more work. We recommend a combination of the following to uniquely determine any simple object <code>a</code>:</p><ul><li>Check the dimension of the simple object: <code>dim(a)</code></li><li>Check the dual of the simple object: <code>dual(a)</code></li><li>Check how this simple object fuses with other (simple) objects: <code>Nsymbol(a,b,c)</code></li></ul><p>The dual object of some simple object <span>$a$</span> of an arbitrary subcategory <span>$\mathcal{C}_{ij}$</span> is defined as the unique object <span>$a^* \in \mathcal{C}_{ji}$</span> satisfying</p><p class="math-container">\[^{}_a \mathbb{1} \in a \times a^* \quad \text{and} \quad \mathbb{1}_a \in a^* \times a\]</p><p>with multiplicity 1.</p><h2 id="Constructing-the-Hamiltonian-and-matrix-product-state"><a class="docs-heading-anchor" href="#Constructing-the-Hamiltonian-and-matrix-product-state">Constructing the Hamiltonian and matrix product state</a><a id="Constructing-the-Hamiltonian-and-matrix-product-state-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-the-Hamiltonian-and-matrix-product-state" title="Permalink"></a></h2><p>TensorKit has been made compatible with the multifusion structure by keeping track of the relevant units in the fusion tree manipulations. With this, we can make <code>GradedSpace</code>s whose objects are in <code>A4Object</code>: </p><pre><code class="language-julia hljs">D1 = A4Object(6, 6, 1) # unit in this case
D2 = A4Object(6, 6, 2) # non-trivial 1d irrep
D3 = A4Object(6, 6, 3) # non-trivial 1d irrep
D4 = A4Object(6, 6, 4) # 3d irrep</code></pre><p>Since we want to replicate a spin-1 Heisenberg model, it makes sense to use the 3-dimensional irrep to grade the physical space, and thus construct our Hamiltonian. We don&#39;t illustrate here how to derive the considered Hamiltonian in a <span>$\mathsf{Rep(A_4)}$</span> basis, but simply give it. For now, we construct a finite-size spin chain; below we will repeat the calculation for an infinite system.</p><pre><code class="language-julia hljs">P = Vect[A4Object](D4 =&gt; 1) # physical space
T = ComplexF64
# usual Heisenberg part
h1_L = TensorMap(zeros, T, P ⊗ P ← P)
h1_R = TensorMap(zeros, T, P ← P ⊗ P)
block(h1_L, D4) .= [0; 1]
block(h1_R, D4) .= [0 1;]
@plansor h1[-1 -2; -3 -4] := h1_L[-1 1; -3] * h1_R[-2; 1 -4]

# biquadratic term
h2_L = TensorMap(zeros, T, P ⊗ Vect[A4Object](D1 =&gt; 1, D2 =&gt; 1, D3 =&gt; 1) ← P)
h2_R = TensorMap(ones, T, P ← Vect[A4Object](D1 =&gt; 1, D2 =&gt; 1, D3 =&gt; 1) ⊗ P)
block(h2_L, D4) .= [4 / 3; 1 / 3; 1 / 3]
@plansor h2[-1 -2; -3 -4] := h2_L[-1 1; -3] * h2_R[-2; 1 -4]

# anti-commutation term
h3_L = TensorMap(zeros, T, P ⊗ P ← P)
h3_R = TensorMap(zeros, T, P ← P ⊗ P)
block(h3_L, D4) .= [1; 0]
block(h3_R, D4) .= [0 1;]
@plansor h3[-1 -2; -3 -4] := h3_L[-1 1; -3] * h3_R[-2; 1 -4]

L = 60
J1 = -2.0 # probing the A4 SSB phase first
J2 = -5.0
lattice = FiniteChain(L)
H1 = @mpoham sum(-2 * h1{i,j} for (i, j) in nearest_neighbours(lattice))
H2 = @mpoham sum(h2{i,j} for (i, j) in nearest_neighbours(lattice))
H3 = @mpoham sum(2im * h3{i,j} for (i, j) in nearest_neighbours(lattice))

H = H1 + J1 * H2 + J3 * H3</code></pre><p>For the matrix product state, we will select <span>$\mathsf{Vec}$</span> as the module category for now:</p><pre><code class="language-julia hljs">M = A4Object(1, 6, 1) # Vec</code></pre><p>and construct the finite MPS:</p><pre><code class="language-julia hljs">D = 40 # bond dimension
V = Vect[A4Object](M =&gt; D)
Vb = Vect[A4Object](M =&gt; 1) # non-degenerate boundary virtual space
init_mps = FiniteMPS(L, P, V; left=Vb, right=Vb)</code></pre><div class="admonition is-warning" id="Important-7d5c5c8ed93678ef"><header class="admonition-header">Important<a class="admonition-anchor" href="#Important-7d5c5c8ed93678ef" title="Permalink"></a></header><div class="admonition-body"><p>We must pass on a left and right virtual space to the keyword arguments <code>left</code> and <code>right</code> of the <code>FiniteMPS</code> constructor, since these would by default try to place a trivial space of the <code>Sector</code>, which does not exist for any <code>BimoduleSector</code> due to the semisimple unit. </p></div></div><h2 id="DMRG2-and-the-entanglement-spectrum"><a class="docs-heading-anchor" href="#DMRG2-and-the-entanglement-spectrum">DMRG2 and the entanglement spectrum</a><a id="DMRG2-and-the-entanglement-spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#DMRG2-and-the-entanglement-spectrum" title="Permalink"></a></h2><p>We can now look to find the ground state of the Hamiltonian with two-site DMRG. We use this instead of the &quot;usual&quot; one-site DMRG because the two-site one will smartly fill up the blocks of the local tensor during the sweep, allowing one to initialise as a product state in one block and more likely avoid local minima, a common occurence in symmetric tensor network simulations. </p><pre><code class="language-julia hljs">dmrg2alg = DMRG2(;verbosity=2, tol=1e-7, trscheme=truncbelow(1e-4))
ψ, _ = find_groundstate(init_mps, H, dmrg2alg)</code></pre><p>The truncation scheme keyword argument is mandatory when calling <code>DMRG2</code> in MPSKit. Here, we choose to truncate such that all singular values are larger than <span>$10^{-4}$</span>, while setting the default tolerance for convergence to <span>$10^{-7}$</span>. More information on this can be found in the <a href="https://github.com/QuantumKitHub/MPSKit.jl">MPSKit</a> documentation. To run one-site DMRG anyway, use <code>DMRG</code> which does not require a truncation scheme.</p><p>Now that we&#39;ve found the ground state, we can compute the entanglement spectrum in the middle of the chain.</p><pre><code class="language-julia hljs">spec = entanglement_spectrum(ψ, round(Int, L/2))</code></pre><p>This returns a dictionary which maps the objects grading the virtual space to the singular values. In this case, there is one key corresponding to <span>$\mathsf{Vec}$</span>. We can also immediately return a plot of this data by the following:</p><pre><code class="language-julia hljs">entanglementplot(ψ;site=round(Int, L/2))</code></pre><p>This plot will show the singular values per object, as well as include the &quot;effective&quot; bond dimension, which is simply the dimension of the virtual space where we cut the system. #TODO: actually include the plot </p><h2 id="Search-for-the-correct-dual-model"><a class="docs-heading-anchor" href="#Search-for-the-correct-dual-model">Search for the correct dual model</a><a id="Search-for-the-correct-dual-model-1"></a><a class="docs-heading-anchor-permalink" href="#Search-for-the-correct-dual-model" title="Permalink"></a></h2><p>Consider a quantum lattice model with its symmetries determing the phase diagram. For every phase in the phase diagram, the dual model for which the ground state maximally breaks all symmetries spontaneously is the one where the entanglement is minimised and the tensor network is represented most efficiently (<a href="../../references/#Lootens_2024">Lootens <em>et al.</em>, 2024</a>). Let us confirm this result, starting with the <span>$\mathsf{Rep(A_4)}$</span> spontaneous symmetry breaking phase. The code will look exactly the same as above, except the virtual space of the MPS will change to be graded by the other module categories:</p><pre><code class="language-julia hljs">module_numlabels(i) = MultiTensorKit._numlabels(A4Object, i, 6) 
V = Vect[A4Object](A4Object(i, 6, label) =&gt; D for label in 1:module_numlabels(i))
Vb = Vect[A4Object](c =&gt; 1 for c in first(sectors(V))) # not all charges on boundary, play around with what is there</code></pre><p>#TODO: show all the plots</p><div class="admonition is-info" id="Additional-functions-and-keyword-arguments-1f2a1f7b8cb8b7cf"><header class="admonition-header">Additional functions and keyword arguments<a class="admonition-anchor" href="#Additional-functions-and-keyword-arguments-1f2a1f7b8cb8b7cf" title="Permalink"></a></header><div class="admonition-body"><p>Certain commonly used functions within MPSKit require extra keyword arguments to be compatible with multifusion MPS simulations. In particular, the keyword argument <code>sector</code> (note the lowercase &quot;s&quot;) appears in </p><ul><li><code>transfer_spectrum</code>: the sector is selected by adding an auxiliary space to the <em>domain</em> of each eigenvector of the transfer matrix. Since in a full contraction the domain of the eigenvector lies in the opposite side of the physical space (labeled by objects in <span>$\mathcal{D} = \mathsf{Rep(A_4)}$</span>), the sectors lie in the symmetry category <span>$\mathcal{C} = \mathcal{D^*_M}$</span>.</li><li><code>correlation_length</code>: since this function calls <code>transfer_spectrum</code>, the same logic applies.</li><li><code>excitations</code> with <code>QuasiparticleAnsatz</code>: similar to the previous functions, charged excitations are selected by adding a charged auxiliary space to the eigenvectors representing the quasiparticle states. </li><li><code>exact_diagonalization</code>: the <code>sector</code> keyword argument now requires an object in <span>$\mathcal{D}$</span>, since this is the fusion category which specifies the bond algebra from which the Hamiltonian is constructed. This is equivalent to adding a charged leg on the leftmost (or rightmost) virtual space of the MPS in conventional MPS cases.</li></ul></div></div><h2 id="Differences-with-the-infinite-case"><a class="docs-heading-anchor" href="#Differences-with-the-infinite-case">Differences with the infinite case</a><a id="Differences-with-the-infinite-case-1"></a><a class="docs-heading-anchor-permalink" href="#Differences-with-the-infinite-case" title="Permalink"></a></h2><p>We can repeat the above calcalations also for an infinite system. The <code>lattice</code> variable will change, as well as the MPS constructor and the algorithm:</p><pre><code class="language-julia hljs">lattice = InfiniteChain(1)
init = InfiniteMPS([P], [V])
inf_alg = VUMPS(; verbosity=2, tol=1e-7)</code></pre><p>Besides <code>VUMPS</code>, <code>IDMRG</code> and <code>IDMRG2</code> are as easy to run with the <code>A4Object</code> <code>Sector</code>. It is also clear that boundary terms do not play a role in this case.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../multifusioncats/">« Extending to multifusion category theory</a><a class="docs-footer-nextpage" href="../../lib/library/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 6 August 2025 13:46">Wednesday 6 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
